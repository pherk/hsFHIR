# N1QL Query Language&mdash;DML

+ Status: DRAFT/PROPOSAL
+ Latest: [n1ql-dml](https://github.com/couchbase/query/blob/master/docs/n1ql-dml.md)
+ Modified: 2017-02-10

## Introduction

N1QL ("nickel") is the query language from Couchbase. N1QL aims to
meet the query needs of distributed document-oriented databases. This
document specifies the syntax and semantics of the data modification
statements in N1QL.

_N1QL_ stands for Non-1st Query Language. The name reflects the fact
that the Couchbase document-oriented data model is based on [Non-1st
Normal Form
(N1NF)](http://en.wikipedia.org/wiki/Database_normalization#Non-first_normal_form_.28NF.C2.B2_or_N1NF.29).

## DML statements

N1QL provides several data modification statements.

_dml-stmt:_

![](diagram/dml-stmt.png)

## INSERT

_insert:_

![](diagram/insert.png)

_keyspace-ref:_

![](diagram/keyspace-ref.png)

_keyspace:_

![](diagram/keyspace.png)

_insert-values:_

![](diagram/insert-values.png)

_values-clause:_

![](diagram/values-clause.png)

_insert-select:_

![](diagram/insert-select.png)

_returning-clause:_

![](diagram/returning-clause.png)

_result-expr:_

![](diagram/result-expr.png)

_path:_

![](diagram/path.png)

_alias:_

![](diagram/alias.png)

## UPSERT

_upsert:_

![](diagram/upsert.png)

## DELETE

_delete:_

![](diagram/delete.png)

_use-clause:_

![](diagram/use-clause.png)

_use-keys-clause:_

![](diagram/use-keys-clause.png)

_use-index-clause:_

![](diagram/use-index-clause.png)

_index-ref:_

![](diagram/index-ref.png)

_index-name:_

![](diagram/index-name.png)

_index-using:_

![](diagram/index-using.png)

_where-clause:_

![](diagram/where-clause.png)

In N1QL DML statements, the LIMIT clause serves as a hint. The query
engine can stop processing records any time after the LIMIT is
reached. The LIMIT is not applied exactly, which is different from
SELECT statements.

_limit-clause:_

![](diagram/limit-clause.png)

## UPDATE

_update:_

![](diagram/update.png)

_set-clause:_

![](diagram/set-clause.png)

_update-for:_

![](diagram/update-for.png)

_unset-clause:_

![](diagram/unset-clause.png)

## MERGE

_merge:_

![](diagram/merge.png)

_merge-source:_

![](diagram/merge-source.png)

_key-clause:_

![](diagram/key-clause.png)

_merge-actions:_

![](diagram/merge-actions.png)

_merge-update:_

![](diagram/merge-update.png)

_merge-delete:_

![](diagram/merge-delete.png)

_merge-insert:_

![](diagram/merge-insert.png)

<!--

## TRUNCATE

TRUNCATE deletes all the documents in a keyspace. It cannot be rolled
back, and it cannot be called within or participate in transactions.

_truncate:_

![](diagram/truncate.png)

__NOTE:__ Because we are distributed and support XDCR, TRUNCATE would
need to work correctly and efficiently across partitions and across
data centers, even as data flows into the keyspace.

One possibility is to first broadcast a KEYSPACE CLEAR message that
causes the keyspace to stop accepting new mutations and to be empty for
new queries. Once the KEYSPACE CLEAR is coordinated, the final TRUNCATE
can be completed (while completing already-started queries).

We may postpone TRUNCATE if the implementation makes it expedient to
do so. Also, we will only expose TRUNCATE via N1QL after the backend
support for it is in place, and perhaps in conjunction with an
administrative API that abstracts / hides all the management and
book-keeping for distributed correctness.

## SELECT-FOR

_select-for:_

![](diagram/select-for.png)

## Transactions

### Start transaction

_start:_

![](diagram/start.png)

### Commit

_commit:_

![](diagram/commit.png)

### Rollback

_rollback:_

![](diagram/rollback.png)

-->

## About this Document

The
[grammar](https://github.com/couchbase/query/blob/master/docs/n1ql-dml.ebnf)
forming the basis of this document is written in a [W3C dialect of
EBNF](http://www.w3.org/TR/REC-xml/#sec-notation).

This grammar has not yet been converted to an actual implementation,
ambiguities and conflicts may still be present.

Diagrams were generated by [Railroad Diagram
Generator](http://railroad.my28msec.com/) ![](diagram/.png)

### Document History

* 2013-07-07 - Initial checkin
    * UPDATE, DELETE, INSERT-VALUES, and INSERT-SELECT
    * Datasets
    * WHERE clauses in INSERT statements
    * RETURNING clauses
* 2013-07-08 - Added to open issues
* 2013-07-12 - Result sets
    * DML statements return result sets (same as SELECT)
* 2013-07-12 - EBNF
    * Added EBNF for dml-stmt
* 2013-07-19 - Merge, Insert-Values, cond
    * Added MERGE statement for upserts, based on input from prod mgmt
    * Moved WHERE clause in INSERT-VALUES syntax
    * Added cond to EBNF diagrams
* 2013-07-30 - Update-Rename, Truncate
    * Added UPDATE-RENAME clause
    * Added TRUNCATE statement
* 2013-07-30 - Truncate
    * Required BUCKET after TRUNCATE, to make it more self-documenting
    * Clarified that TRUNCATE does not participate in transactions
* 2013-12-15 - Target syntax
    * Updated syntax targeting beta / production release
    * DML statements apply to documents, not fragments
    * Transaction START / COMMIT / ROLLBACK statements
* 2014-01-03 - MERGE
    * Restricted MERGE to key-based matching
    * Made LIMIT mandatory in MERGE
* 2014-01-21 - Collection expressions
    * Per customer requirement, extend collection expressions to
      multiple collections
    * Customer requirement: If you have a property that is an array of
      subdocuments like the children property in your examples, it
      looks easy to find the documents where there is a child with the
      gender equal to female and the age greater than 12 say for
      example.  Now suppose the data is stored differently.  There are
      now two properties in the document, each being an array, one for
      the list of children genders and one for the list of children
      ages.  In this case the gender on line one corresponds to the
      age on line one.  How would you search the document such that
      the lines matched up?  How do you make sure the line that is
      female is also the line where the age is greater than 12?  Now
      take that one step further and put the two properties into two
      separate documents.  You still want to find the documents where
      the search criteria are true on the same line in each document.
      How do you do that?  We need to be able to relate multiple
      properties together on a line by line basis and they may be
      stored separately.
* 2014-02-06 - Transactions
    * Remove transaction statements for now
* 2014-02-12 - UPSERT
    * Add UPSERT option to INSERT
* 2014-02-13 - RETURNING
    * Omit result expressions to return raw value
* 2014-02-16 - RETURNING RAW
    * Add RETURNING RAW
* 2014-02-17 - KEY / KEYS
    * Clean up usage of KEY and kEYS
* 2014-02-18 - RETURNING list
    * Require RETURNING list
* 2014-06-24 - VALUES exprs
    * Change VALUES to multiple exprs
* 2014-06-24 - RETURNING star
    * Allow star in RETURNING
* 2014-07-02 - MERGE source
    * Support VALUES as MERGE source
    * Allow JOIN sources to be aliased
* 2014-08-10 - WITHIN
    * Add WITHIN
* 2014-09-02 - MERGE
    * Factor out merge actions
* 2014-09-06 - MERGE
    * Simiplify MERGE syntax: remove from-term.
* 2014-09-10 - VALUES expr
    * Change VALUES back to single expr
* 2014-10-11 - Syntax
    * Simplify MERGE
    * Change KEYS to USE [ PRIMARY ] KEYS
    * Rename BUCKET to KEYSPACE
* 2014-10-19 - INSERT / UPSERT syntax
    * Allow keys to exist outside of values
* 2014-12-15 - INSERT / UPSERT syntax
    * Refine INSERT / UPSERT syntax
* 2014-12-21 - MERGE syntax
    * Include key-clause in MERGE syntax diagrams
* 2015-04-03 - Hints
    * Add syntax for index hints
* 2015-04-04 - LIMIT
    * Explain that LIMIT is not exact
* 2016-03-28 - Ranging over objects
    * Add syntax for UPDATE with ranging over objects
* 2016-06-07 - Chained UPDATE FOR
    * Add syntax for chained UPDATE FOR
* 2017-02-10 - MERGE source
    * Support expressions as MERGE source

### Open Issues

This meta-section records open issues in this document, and will
eventually disappear.
